# -*- coding: utf-8 -*-
"""assign3deeploycv4

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XxKWC3UOOpuxxFTQTsBh0Ujwb9tGtmMS
"""

# Install required libraries
!pip install tensorflow tf-keras-vis matplotlib

# Import necessary libraries
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from tf_keras_vis.gradcam import Gradcam
from tf_keras_vis.utils.scores import CategoricalScore
from tensorflow.keras.applications.vgg16 import VGG16, preprocess_input
from tensorflow.keras.preprocessing.image import load_img, img_to_array
from google.colab import files
import cv2

# Upload the image
uploaded = files.upload()

# Process each uploaded image
for each_path in uploaded.keys():
    # Load and preprocess the image
    img = load_img(each_path, target_size=(224, 224))
    img_array = img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
    img_array = preprocess_input(img_array)  # Preprocess the image for VGG16

    # Extract image name
    name = each_path.split("/")[-1].split(".jpeg")[0]

    # Load the VGG16 model with ImageNet weights
    model = VGG16(weights='imagenet', include_top=True)

    # Initialize the Grad-CAM explainer
    explainer = Gradcam(model, clone=True)

    # Define the class index score to use for Grad-CAM
    score = CategoricalScore(np.argmax(model.predict(img_array)))  # Use predicted class

    # Apply Grad-CAM to get the heatmap
    grid = explainer(score, img_array, penultimate_layer='block5_conv3')  # Specify the correct layer

    # Post-process the Grad-CAM output (resize and normalize heatmap)
    heatmap = grid[0]

    # Expand dimensions to add the channel axis if needed
    if len(heatmap.shape) == 2:  # Ensure heatmap has shape (height, width, channels)
        heatmap = np.expand_dims(heatmap, axis=-1)

    # Resize heatmap
    heatmap_resized = tf.image.resize(heatmap, (224, 224)).numpy()

    # Normalize heatmap to 0-255
    heatmap_resized = np.uint8(255 * heatmap_resized.squeeze())

    # Apply a color map to the heatmap
    heatmap_colored = cv2.applyColorMap(heatmap_resized, cv2.COLORMAP_JET)

    # Normalize original image for blending
    img_original = np.array(img) / 255.0  # Normalize the original image to 0-1
    heatmap_colored = heatmap_colored / 255.0  # Normalize heatmap to 0-1

    # Superimpose the heatmap on the original image
    superimposed_img = img_original * 0.6 + heatmap_colored * 0.4  # Blend the two images

    # Save the Grad-CAM superimposed output
    output_path = name + '_grad_cam_superimposed.png'
    plt.imsave(output_path, superimposed_img)  # Save the superimposed image

    # Display the original image, Grad-CAM, and superimposed output side by side
    fig, axes = plt.subplots(1, 4, figsize=(15, 5))
    img_original = np.array(img) / 255.0
    axes[0].imshow(img_original)  # Original image
    axes[0].set_title("Original Image")
    axes[0].axis("off")

    axes[1].imshow(grid[0], cmap='jet')  # Grad-CAM output in isolation
    axes[1].set_title("Grad-CAM Output")
    axes[1].axis("off")


    axes[2].imshow(heatmap_resized, cmap='jet')  # Grad-CAM heatmap
    axes[2].set_title("Grad-CAM Heatmap")
    axes[2].axis("off")

    axes[3].imshow(superimposed_img)  # Superimposed output
    axes[3].set_title("Superimposed Image")
    axes[3].axis("off")

    plt.tight_layout()
    plt.show()